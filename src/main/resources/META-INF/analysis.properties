first.timestamp.threshold.exceeded=First timestamp is greater than threshold. Partial log file or unrecognized logging format.
thread.stack.size.not.set=Explicitly set the thread stack size with the -Xss (n/a Solaris) or -XX:ThreadStackSize option, as the default size is typically much larger than needed. Start with 128k, and if you get StackOverflowError, increase by increments of 64k until StackOverflowError goes away. For example: (1) -Xss128k, (2) -XX:ThreadStackSize=128k (Solaris).
thread.stack.size.large=The thread stack size is on the large side (>= 1024k). Typical values are 128k or 256k. Please confirm a large thread stack size is needed.
min.heap.not.equal.max.heap=For production environments, it is recommended to set the minimum heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -XX:PermSize=128M -XX:MaxPermSize=128M.
perm.metaspace.not.set=The permanent generation (JDK7 and earlier) or Metaspace (starting JDK8) size should be explicitly set. The default permanent generation size is very small (e.g. 64MB in server mode), so not setting it can lead to OutOfMemoryError. The Metaspace size is unlimited by default and will auto increase in size up to what the OS will allow, so not setting it can swamp the OS. Explicitly set the permanent generation size (e.g. -XX:PermSize=128M -XX:MaxPermSize=128M) or Metaspace size (e.g. -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M).    
min.perm.not.equal.max.perm=For production environments, it is recommended to set the minimum permanent generation size (-XX:PermSize) and maximum permanent generation size (-XX:MaxPermSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the permanent generation space. (2) If using large pages, memory is reserved for the JVM based on the maximum permanent generation size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -Xms4096M -Xmx4096M.
min.metaspace.not.equal.max.metaspace=For production environments, it is recommended to set the minimum Metaspace size (-XX:MetaspaceSize) and maximum Metaspace size (-XX:MaxMetaspaceSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the Metaspace. (2) If using large pages, memory is reserved for the JVM based on the maximum Metaspace size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -XX:MetaspaceSize=128M -XX:MaxMetaspaceSize=128M.
rmi.dgc.not.managed=Many environments (e.g. JBoss versions prior to EAP6) cause the RMI subsystem to be loaded. RMI manages Distributed Garbage Collection (DGC) by calling System.gc() every minute (default JDK5 and earlier) or every hour (JDK6 on) to clean up unreachable remote objects, resulting in unnecessary major (full) garbage collection that can seriously impact performance. DGC is required to prevent memory leaks when making remote method calls or exporting remote objects like EJBs; however, test explicitly setting the DGC client and server intervals to longer intervals to minimize the impact of explicit garbage collection. For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection alltogether with -XX:+DisableExplicitGC.
rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000).
rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000).
heap.dump.on.oome.missing=Add -XX:+HeapDumpOnOutOfMemoryError. This option does not impact performance (until the heap is actually written out); it is simply a flag to indicate that a heap dump should be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error. 
application.stopped.time.missing=-XX:+PrintGCApplicationStoppedTime missing. Required to determine overall throughput and identify throughput and pause issues not related to garbage collection, as many JVM operations besides garbage collection require all threads to reach a safepoint to execute.
explicit.gc.unnecessary=Add -XX:+DisableExplicitGC if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible the application depends on explicit garbage collection in some other way. Instead, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000.
explicit.gc.unnecessary.cms.g1=Add -XX:+DisableExplicitGC if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible your application depends on explicit garbage collection in some other way. Instead add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
explicit.gc.serial=Calls to System.gc() are causing a slow (single threaded) serial collector (CMS_SERIAL_OLD or G1_FULL_GC) to be invoked. Add -XX:+DisableExplicitGC if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible your application depends on explicit garbage collection in some other way. Instead add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
explicit.gc.disabled=Explicit garbage collection has been disabled with -XX:+DisableExplicitGC. That is fine if the JVM is not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible the application depends on explicit garbage collection in some other way. If explicit garbage collection is required, remove -XX:+DisableExplicitGC and set sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 hour. For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000.
explicit.gc.not.concurrent=Add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently by the CMS and G1 collectors. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection alltogether with -XX:+DisableExplicitGC.
explicit.gc.disabled.concurrent=Remove -XX:+ExplicitGCInvokesConcurrent since explicit garbage collection has been disabled with -XX:+DisableExplicitGC.
gc.stopped.ratio=A significant amount of stopped time (>20%) is not GC related. Check for inverted parallelism and other GC operations that require a safepoint: Deoptimization, PrintThreads, PrintJNI, FindDeadlock, ThreadDump, EnableBiasLocking, RevokeBias, HeapDumper, GetAllStackTrace.
serial.gc.throughput=The PARALLEL_SERIAL_OLD (single-threaded) collector is being invoked. Add -XX:+UseParallelOldGC to use the more efficient PARALLEL_OLD_COMPACTING collector added in JDK 6.   
serial.gc.cms=The CMS_SERIAL_OLD (single threaded) collector is being invoked. Causes: (1) Fragmentation. The concurrent low pause collector does not compact. When fragmentation becomes an issue a serial collection compacts the heap. If the old generation has available space, the cause is likely fragmentation. Fragmentation can be avoided by increasing the heap size. (2) Resizing perm space. If perm occupancy is near perm allocation, the cause is likely perm space resizing. Perm space resizing can be avoided by setting the minimum heap size (-Xms, -XX:InitialHeapSize) equal to the the maximum heap size (-Xmx, -XX:MaxHeapSize). For example: -XX:PermSize=128M -XX:MaxPermSize=128M. (3) Undetermined reasons. Possibly the JVM requires a certain amount of heap or combination of resources that is not being met, and consequently the concurrent low pause collector is not used despite being specified with the -XX:+UseConcMarkSweepGC option.
serial.gc.g1=The G1 Full GC serial (single-threaded) collector is being invoked. The G1 Full GC collector is a serial (single-threaded) collector, which means it will take a very long time to collect a large heap. If the G1 collector is running optimally, there will not be any G1 Full GC collections. G1 Full GCs happen when the old space or Metaspace fills up and can no longer be expanded. Reasons the old space cannot be expanded: (1) it is filled with humongous objects (which can only be collected by the G1 Full GC collector), (2) the heap is swamped before the marking cycle is able to complete and a mixed collection reclaim space, (3) the heap is simply too small, (4) Bugs in JDK7 that cause G1 Full GC collections. For example: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8030849.
instrumentation=Instrumentation is being used (-javaagent).
bytecode.compile.background.disabled=Bytecode background compilation is disabled. Remove -Xbatch or -XX:-BackgroundCompilation to compile bytecode in the background so threads do not block waiting but instead run in interpreter mode until the compilation is complete. 
bytecode.compile.first.invocation=Methods being compiled on first invocation. Remove -Xcomp to enabled the JVM to efficiently decide when to compile methods into bytecode.
bytecode.compile.disabled=Compilation to native code is disabled. Remove -Xint to allow the just in time (JIT) compiler to compile to native code for increased performance.
print.commandline.flags=Add -XX:+PrintCommandLineFlags to output the JVM command line options at the beginning of the gc log. This is critical information for gc analysis.
print.gc.details.missing=Add -XX:+PrintGCDetails to output details at gc that are needed for gc analysis.
cms.new.serial.old=Add -XX:+UseConcMarkSweepGC to use the CMS collector for the old generation. When -XX:+UseParNewGC is used alone the CMS collector is only used to collect the young generation, and the older, slower serial collector is used to collect the old generation.
cms.concurrent.mode.failure=Concurrent mode failure. The concurrent collection of the old generation did not finish before the old generation became full. There is not enough space in the old generation to support the rate of promotion from the young generation. The JVM initiates a full GC using a slow (single threaded) serial collector in an attempt to free space. The concurrent low pause collector measures the rate at which the the old generation is filling and the amount of time between collections and uses this historical data to calculate when to start the concurrent collection (plus adds some padding) so that it will finish just in time before the old generation becomes full. Possible causes: (1) The heap is too small. (2) There is a change in application behavior (e.g. a load increase) that causes the young promotion rate to exceed historical data. If this is the case, the concurrent mode failures will happen near the change in behavior, then after a few collections the CMS collector will adjust based on the new promotion rate. Performance will suffer for a short period until the CMS collector recalibrates. Use -XX:CMSInitiatingOccupancyFraction=NN (default 92) to handle changes in application behavior; however, the tradeoff is that there will be more collections. (3) The application has large variances in object allocation rates, causing large variances in young generation promotion rates, leading to the CMS collector not being able to accurately predict the time between collections. Use -XX:CMSIncrementalSafetyFactor=NN (default 10) to start the concurrent collection NN% sooner than the calculated time. (4) There is premature promotion from the young to the old generation, causing the old generation to fill up with short-lived objects. The default value for -XX:MaxTenuringThreshold for the CMS collector is 0, meaning that objects surviving a young collection are immediately promoted to the old generation. Use -XX:MaxTenuringThreshold=32 to allow more time for objects to expire in the young generation. (5) If the old generation has available space, the cause is likely fragmentation. Fragmentation can be avoided by increasing the heap size. (6) The Perm/Metaspace fills up during the CMS cycle. The CMS collector does not collect Perm/Metaspace by default. Add -XX:+CMSClassUnloadingEnabled to collect Perm/Metaspace in the CMS concurrent cycle. If the concurrent mode failure is not able to reclaim Perm/Metaspace, also increase the size. For example: -XX:PermSize=256M -XX:MaxPermSize=256M (Perm) or -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M (Metaspace).
cms.classunloading.missing=The CMS collector does not collect Perm/Metaspace by default. Add -XX:+CMSClassUnloadingEnabled to collect Perm/Metaspace in the CMS concurrent cycle and avoid Perm/Metaspace collections being done by a slow (single threaded) serial collector.
cms.promotion.failed=CMS promotion failed. The old generation has available space, but it is not contiguous. The concurrent low pause collector does not compact, so when fragmentation becomes an issue the slow (single-threaded) serial collector is invoked to compact the heap. Fragmentation can be avoided by increasing the heap size. 