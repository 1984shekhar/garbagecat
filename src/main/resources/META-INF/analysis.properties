first.timestamp.threshold.exceeded=First timestamp is greater than threshold. Partial log file or unrecognized logging format.
thread.stack.size.not.set=Explicitly set the thread stack size with the -Xss (n/a Solaris) or -XX:ThreadStackSize option, as the default size is typically much larger than needed. For example: "-Xss128k". Start with 128k, and if you get a StackOverflowError, increase by increments of 64k until the StackOverflowError goes away.
#thread.stack.size.large=The thread stack size is on the large side. Typical values are 128k or 256k. Please confirm a thread stack size that large is needed.
min.heap.not.equal.max.heap=For production environments, it is recommended to set the minimum heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collections the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory.
min.perm.not.equal.max.perm=For production environments, it is recommended to set the minimum permanent generation size (-XX:PermSize) and maximum permanent generation size (-XX:MaxPermSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collections the JVM has to do to resize the permanent generation space. (2) If using large pages, memory is reserved for the JVM based on the maximum permanent generation size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory.
#rmi.dgc.not.set=Many environments (e.g. JBoss) cause the RMI subsystem to be loaded. RMI manages Distributed Garbage Collection (DGC) by calling System.gc() every minute to clean up unreachable remote objects, resulting in unnecessary major (full) garbage collections that can seriously impact performance. It is recommended to explicitly set the RMI DGC interval longer (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000) if the application calls or exports remote ojbects (e.g. EJBs) or disable explicit garbage collection (-XX:+DisableExplicitGC).
#sun.rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
#sun.rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
#sun.rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000).
#sun.rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000).
#heap.dump.on.out.of.memory.error.missing=This option does not impact performance (until the heap is actually written out); it is simply a flag to indicate that a heap dump should be generated when the first thread throws OutOfMemoryError. This JVM argument should always be used when available, as it provides critical information in case of a memory error.
application.stopped.time.missing=-XX:+PrintGCApplicationStoppedTime missing. Required to determine overall throughput and identify throughput and pause issues not related to garbage collection, as many JVM operations besides garbage collection require all threads to reach a safepoint to execute.
explicit.gc.unnecessary=Add -XX:+DisableExplicitGC if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible your application depends on explicit garbage collection in some other way. Instead, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 hour. For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000.
explicit.gc.unnecessary.cms.g1=Add -XX:+DisableExplicitGC if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible your application depends on explicit garbage collection in some other way. Instead add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collections are handled concurrently.
explicit.gc.serial=Calls to System.gc() are causing a slow (single threaded) serial collector (CMS_SERIAL_OLD or G1_FULL_GC) to be invoked. Add -XX:+DisableExplicitGC if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM). If there are remote objects, do not use -XX:+DisableExplicitGC, as it can result in a memory leak. It is also possible your application depends on explicit garbage collection in some other way. Instead add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collections are handled concurrently.
gc.stopped.ratio=A significant amount of stopped time (>20%) is not GC related. Check for inverted parallelism and other GC operations that require a safepoint: Deoptimization, PrintThreads, PrintJNI, FindDeadlock, ThreadDump, EnableBiasLocking, RevokeBias, HeapDumper, GetAllStackTrace.
throughput.serial.gc=The PARALLEL_SERIAL_OLD (single-threaded) collector is being invoked. Add -XX:+UseParallelOldGC to use the more efficient PARALLEL_OLD_COMPACTING collector added in JDK 6.   
cms.serial.gc=
g1.serial.gc=The G1_FULL_GC serial (single-threaded) collector is being invoked. The G1 Full GC collector is a serial (single-threaded) collector, which means it will take a very long time to collect a large heap. If the G1 collector is running optimally, there will not be any G1 Full GC collections. G1 Full GCs happen when the PermGen/Metaspace fills up or when there are more allocations than the G1 can concurrently collect.